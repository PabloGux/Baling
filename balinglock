/**

 *
 */
import groovy.json.JsonSlurper
import groovy.json.JsonOutput


metadata {
	definition (name: "Baling Lock EZ-31S", namespace: "pgux", author: "pgux") {
		capability "Lock"
		capability "Lock Codes"
		capability "Battery"
		attribute "lastCheckin", "String"

		command "testUnlockWithCode", ["NUMBER"]
        command "testUnlockWithUserNumber" , ["NUMBER"]

	}

	preferences {
		input name: "infoLogging", type: "bool", title: "Enable info message logging", description: ""
		input name: "debugLogging", type: "bool", title: "Enable debug message logging", description: ""

	}
}

// Globals - Cluster IDs
private getCLUSTER_POWER() { 0x0001 }
private getCLUSTER_DOORLOCK() { 0x0101 }
private getCLUSTER_ALARM() { 0x0009 }

// Globals - Command IDs
private getDOORLOCK_CMD_LOCK_DOOR() { 0x00 }
private getDOORLOCK_CMD_UNLOCK_DOOR() { 0x01 }
private getDOORLOCK_CMD_USER_CODE_SET() { 0x05 }
private getDOORLOCK_CMD_USER_CODE_GET() { 0x06 }
private getDOORLOCK_CMD_CLEAR_USER_CODE() { 0x07 }
private getDOORLOCK_RESPONSE_OPERATION_EVENT() { 0x20 }
private getDOORLOCK_RESPONSE_PROGRAMMING_EVENT() { 0x21 }
private getPOWER_ATTR_BATTERY_PERCENTAGE_REMAINING() { 0x0021 }
private getDOORLOCK_ATTR_LOCKSTATE() { 0x0000 }
private getDOORLOCK_ATTR_NUM_PIN_USERS() { 0x0012 }
private getDOORLOCK_ATTR_MAX_PIN_LENGTH() { 0x0017 }
private getDOORLOCK_ATTR_MIN_PIN_LENGTH() { 0x0018 }
private getDOORLOCK_ATTR_SEND_PIN_OTA() { 0x0032 }
private getALARM_ATTR_ALARM_COUNT() { 0x0000 }
private getALARM_CMD_ALARM() { 0x00 }




////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Parse incoming device messages to generate events
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////

def parse(String description) {
	def cluster = description.split(",").find {it.split(":")[0].trim() == "cluster"}?.split(":")[1].trim()
	def attrId = description.split(",").find {it.split(":")[0].trim() == "attrId"}?.split(":")[1].trim()
	def encoding = Integer.parseInt(description.split(",").find {it.split(":")[0].trim() == "encoding"}?.split(":")[1].trim(), 16)
	def valueHex = description.split(",").find {it.split(":")[0].trim() == "value"}?.split(":")[1].trim()
	def deviceName = device.displayName
	Map map = [:]
	Map responseMap = [:]
	def result = []

	displayDebugLog("parse(): Parsing message: ${description}")
	displayDebugLog("parse(): Message payload: ${valueHex}")

	// lastCheckin can be used with webCoRE
	sendEvent(name: "lastCheckin", value: now())
  
	if (cluster == CLUSTER_DOORLOCK) {  
 		//0101 door unlock
		if (valueHex.substring(8,10) != "00")
		{
			def userCode = Integer.parseInt(valueHex.substring(8,10),16);
			displayDebugLog("parse(): Cluster is 0101 - User Unlock in dec: ${userCode}")
			responseMap.name = "lock"
			responseMap.value = "unlocked"
			def lockCode = lockCodes.find{ it.key == userCode }
			if (lockCode){
                displayDebugLog ("parse(): username found ${lockCode.value} forming map Data" )
        			responseMap.data = ["${lockCode.key}":lockCode.value]
        			displayDebugLog ("parse(): Response Data was formed: ${responseMap.data}")
    			} else {
         			displayDebugLog ("parse(): unlock code not found in database!")
				    responseMap.data = ["${userCode}":[name:"${userCode}", code:"${userCode}"]]
    			}
		}
		else
		{
			displayDebugLog("parse(): Cluster is 0101, User is 00 - Door is now locked")
			responseMap.name = "lock"
			responseMap.value = "locked"
			responseMap.descriptionText = "locked"
		}
	}
	else if (cluster == CLUSTER_POWER && attrId == "0021") {
		displayDebugLog	("parse(): Cluster is 0001 - Battery info - POWER_ATTR_BATTERY_PERCENTAGE_REMAINING")
		responseMap.name = "battery"
		responseMap.value = Math.round(Integer.parseInt(valueHex, 16) / 2)
        displayDebugLog	("parse(): Battery is at ${responseMap.value}%")
		responseMap.descriptionText = "Battery is at ${responseMap.value}%"
	}
	else if (cluster == "0003") {
		displayDebugLog	("parse(): Cluster is 0003 - Identification request")
		responseMap.name = "lastCheckin"
		responseMap.value = now()
	}
	else {
		displayDebugLog("parse(): Unknow cluster ${cluster}!!****************************************************************************************************")
		responseMap.name = "lastCheckin"
		responseMap.value = now()
	}
	

	
	// createEvent returns a Map that defines an Event
	result = createEvent(responseMap)
	displayDebugLog("parse(): Exiting method returning with event created as follow: $result")
	return result
}








// Reverses order of bytes in hex string
def reverseHexString(hexString) {
	def reversed = ""
	for (int i = hexString.length(); i > 0; i -= 2) {
		reversed += hexString.substring(i - 2, i )
	}
	return reversed
}


// Convert raw 4 digit integer voltage value into percentage based on minVolts/maxVolts range
private parseBattery(description) {
}




//////////////////////////////////////////////////////////////
// capability commands
/////////////////////////////////////////////////////////////
def lock(){
    displayDebugLog ("lock() method called")
    sendEvent(name:"lock",value:"locked", type:"digital")
}

def unlock(){
    displayDebugLog ("unlock() method called")
    sendEvent(name:"lock",value:"unlocked", type:"digital")
}

/***** API CALL ****/
def getCodes() {
    displayDebugLog ("getCodes() was called")
    def jsonResponse = JsonOutput.toJson(getLockCodes())
    displayDebugLog ("getCodes method return :${jsonResponse}")
    sendEvent (name: "lockCodes", value: jsonResponse, descriptionText: "'lockCodes' attribute updated")
    return jsonResponse
}

/***** helper, not apo ******/
private getLockCodes() {
	def hardCodes = [
    			1 : [name : 'Admin', code: '10000001'],
    			11 : [name : 'Pablo', code: '10000002'],
    			12 : [name : 'Alejandro', code: '10000003'],
    			13 : [name : 'Dario', code: '10000004'],
    			14 : [name : 'Mary', code: '10000005'],
                15 : [name : 'Ricardo', code: '10000005']
			]
	displayDebugLog ("getLockCodes() was called")
	return hardCodes
	//return '{1:{name:"Admin",code:"00000000"},11:{name:"Pablo",code:"00000000"},12:{name:"Alejandro",code:"00000000"},13:{name:"Dario",code:"00000000"}}'
}

// configure() runs after installed() when a sensor is paired or reconnected
def configure() {
}

// updated() will run every time user saves preferences
def updated() {
	displayDebugLog ("Updating preference settings")
	init()
	displayDebugLog ("Info message logging enabled")
	displayDebugLog ("Debug message logging enabled")
}

def init() {

}

def deleteCode(x) {
    displayDebugLog ("API deleteCode not implemented yet in Baling ")
}

def setCodeLength(length) {
   displayDebugLog ("API setCodeLength not implemented yet in Baling ")
   def descriptionText = "${device.displayName} codeLength set to ${length}"
   sendEvent(name:"codeLength",value:length,descriptionText:"API setCodeLength not implemented yet in Baling")
}

def setCode(codeNumber, code, name = null) {
    displayDebugLog ("API setCode not implemented yet in Baling ")
}







//////////////////////////////////////////////////////////////
// helper functions
/////////////////////////////////////////////////////////////

private def displayDebugLog(message) {
	if (debugLogging)
		log.debug "${device.displayName}: ${message}"
}

private def displayInfoLog(message) {
	if (infoLogging || state.prefsSetCount != 1)
		log.info "${device.displayName}: ${message}"
}



/**
 * Validates attributes and if attributes are not populated, adds the command maps to list of commands
 * @return List of command maps or empty list
 */
def validateAttributes() {
	def cmds = []
	if (!state.attrAlarmCountSet) {
		state.attrAlarmCountSet = true
		cmds += zigbee.configureReporting(CLUSTER_ALARM, ALARM_ATTR_ALARM_COUNT,
				DataType.UINT16, 0, 21600, null)
	}
	// DOORLOCK_ATTR_SEND_PIN_OTA is sometimes getting reset to 0. Hence, writing it explicitly to 1.
	cmds += zigbee.writeAttribute(CLUSTER_DOORLOCK, DOORLOCK_ATTR_SEND_PIN_OTA, DataType.BOOLEAN, 1)
	if(!device.currentValue("maxCodes")) {
		cmds += zigbee.readAttribute(CLUSTER_DOORLOCK, DOORLOCK_ATTR_NUM_PIN_USERS)
	}
	if(!device.currentValue("minCodeLength")) {
		cmds += zigbee.readAttribute(CLUSTER_DOORLOCK, DOORLOCK_ATTR_MIN_PIN_LENGTH)
	}
	if(!device.currentValue("maxCodeLength")) {
		cmds += zigbee.readAttribute(CLUSTER_DOORLOCK, DOORLOCK_ATTR_MAX_PIN_LENGTH)
	}
	cmds = cmds.flatten()
	displayDebugLog ("validateAttributes returning commands list: $cmds")
	cmds
}



/**
 * Called on app installed
 */
def installed(){
    log.warn "installed..."
    sendEvent(name:"maxCodes",value:20)
    sendEvent(name:"codeLength",value:8)
    lock()
}






/**
* Test Command to test codes
**/
def testUnlockWithCode(code = null){
       displayDebugLog ("testUnlockWithCode() called with code: ${code}")
    /*
	lockCodes in this context calls the helper function getLockCodes()
	*/
    def lockCode = lockCodes.find{ it.value.code == "${code}" }

    if (lockCode){
        def data = ["${lockCode.key}":lockCode.value]
        def descriptionText = "${device.displayName} was unlocked [physical]"
	displayDebugLog ("testUnlockWithCode() sending unlock event with data: ${data} and description ${descriptionText}")
	sendEvent(name:"lock",value:"unlocked",descriptionText: descriptionText, type:"physical",data:data)
    } else {
         displayDebugLog ("testUnlockWithCode() code not found! ending")
    }
}


def testUnlockWithUserNumber(code = null){
    displayDebugLog ("testUnlockWithUserNumber() called with code: ${code}")
    /*
	lockCodes in this context calls the helper function getLockCodes()
	*/
    def lockCode = lockCodes.find{ it.key == code }

    if (lockCode){
        def data = ["${lockCode.key}":lockCode.value]
        def descriptionText = "${device.displayName} was unlocked [physical]"
	    displayDebugLog ("testUnlockWithUserNumber() sending unlock event with data: ${data} and description ${descriptionText}")
	    sendEvent(name:"lock",value:"unlocked",descriptionText: descriptionText, type:"physical",data:data)
    } else {
         displayDebugLog ("testUnlockWithUserNumber() code ${code} not found! ending")
    }
}

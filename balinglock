/**

 *
 */
import groovy.json.JsonSlurper
import groovy.json.JsonOutput


metadata {
	definition (name: "Baling Lock EZ-31S", namespace: "pgux", author: "pgux") {
		capability "Lock"
		capability "Lock Codes"
		capability "Battery"

		attribute "lastCheckin", "String"
		attribute "lastOpened", "String"
		attribute "lastClosed", "String"
		attribute "batteryLastReplaced", "String"

		// fingerprint for Xiaomi "Original" Door/Window Sensor
		// fingerprint endpointId: "01", profileId: "0104", deviceId: "0104", inClusters: "0000,0003,FFFF,0019", outClusters: "0000,0004,0003,0006,0008,0005,0019", manufacturer: "LUMI", model: "lumi.sensor_magnet"

		// fingerprint for Xiaomi Aqara Door/Window Sensor
		// fingerprint endpointId: "01", profileId: "0104", deviceId: "5F01", inClusters: "0000,0003,FFFF,0006", outClusters: "0000,0004,FFFF", manufacturer: "LUMI", model: "lumi.sensor_magnet.aq2"

		command "testUnlockWithCode", ["NUMBER"]

	}

	preferences {
		//Battery Voltage Range
 		//input name: "voltsmin", title: "Min Volts (0% battery = ___ volts, range 2.0 to 2.7). Default = 2.5 Volts", description: "", type: "decimal", range: "2..2.7"
 		//input name: "voltsmax", title: "Max Volts (100% battery = ___ volts, range 2.8 to 3.4). Default = 3.0 Volts", description: "", type: "decimal", range: "2.8..3.4"
 		//Logging Message Config
		input name: "infoLogging", type: "bool", title: "Enable info message logging", description: ""
		input name: "debugLogging", type: "bool", title: "Enable debug message logging", description: ""
		//Firmware 2.0.5 Compatibility Fix Config
		//input name: "oldFirmware", type: "bool", title: "DISABLE 2.0.5 firmware compatibility fix (for users of 2.0.4 or earlier)", description: ""
	}
}

// Globals - Cluster IDs
private getCLUSTER_POWER() { 0x0001 }
private getCLUSTER_DOORLOCK() { 0x0101 }
private getCLUSTER_ALARM() { 0x0009 }

// Globals - Command IDs
private getDOORLOCK_CMD_LOCK_DOOR() { 0x00 }
private getDOORLOCK_CMD_UNLOCK_DOOR() { 0x01 }
private getDOORLOCK_CMD_USER_CODE_SET() { 0x05 }
private getDOORLOCK_CMD_USER_CODE_GET() { 0x06 }
private getDOORLOCK_CMD_CLEAR_USER_CODE() { 0x07 }
private getDOORLOCK_RESPONSE_OPERATION_EVENT() { 0x20 }
private getDOORLOCK_RESPONSE_PROGRAMMING_EVENT() { 0x21 }
private getPOWER_ATTR_BATTERY_PERCENTAGE_REMAINING() { 0x0021 }
private getDOORLOCK_ATTR_LOCKSTATE() { 0x0000 }
private getDOORLOCK_ATTR_NUM_PIN_USERS() { 0x0012 }
private getDOORLOCK_ATTR_MAX_PIN_LENGTH() { 0x0017 }
private getDOORLOCK_ATTR_MIN_PIN_LENGTH() { 0x0018 }
private getDOORLOCK_ATTR_SEND_PIN_OTA() { 0x0032 }
private getALARM_ATTR_ALARM_COUNT() { 0x0000 }
private getALARM_CMD_ALARM() { 0x00 }




////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Parse incoming device messages to generate events
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////

def parse(String description) {
	def cluster = description.split(",").find {it.split(":")[0].trim() == "cluster"}?.split(":")[1].trim()
	def attrId = description.split(",").find {it.split(":")[0].trim() == "attrId"}?.split(":")[1].trim()
	def encoding = Integer.parseInt(description.split(",").find {it.split(":")[0].trim() == "encoding"}?.split(":")[1].trim(), 16)
	def valueHex = description.split(",").find {it.split(":")[0].trim() == "value"}?.split(":")[1].trim()
	def deviceName = device.displayName
	Map map = [:]
	Map responseMap = [:]
	def result = []

	//if (!oldFirmware & valueHex != null & encoding > 0x18 & encoding < 0x3e) {
		//displayDebugLog("Data type of payload is little-endian; reversing byte order")
		// Reverse order of bytes in description's payload for LE data types - required for Hubitat firmware 2.0.5 or newer
		//valueHex = reverseHexString(valueHex)
	//}

	displayDebugLog("parse(): Parsing message: ${description}")
	displayDebugLog("parse(): Message payload: ${valueHex}")

	// lastCheckin can be used with webCoRE
	sendEvent(name: "lastCheckin", value: now())

	// Send message data to appropriate parsing function based on the type of report
/*	if (cluster == "0006") {
		// Parse open / closed status report
		map = parseContact(Integer.parseInt(valueHex))
	} else if (attrId == "0005") {
		displayDebugLog("Reset button was short-pressed")
		// Parse battery level from longer type of announcement message
		map = (valueHex.size() > 60) ? parseBattery(valueHex.split('FF42')[1]) : [:]
	} else if (attrId == "FF01" || attrId == "FF02") {
		// Parse battery level from hourly announcement message
		map = (valueHex.size() > 30) ? parseBattery(valueHex) : [:]
	} else {
		displayDebugLog("Unable to parse message")
	}*/
  
	if (cluster == "0101") {  
 		//0101 door unlock
		if (valueHex.substring(8,10) != "00")
		{
			def userCode = Integer.parseInt(valueHex.substring(8,10),16);
			displayDebugLog("parse(): Cluster is 0101 - User Unlock in dec: ${userCode}")
			responseMap.name = "lock"
			responseMap.value = "unlocked"
			responseMap.descriptionText = "Unlocked by ${userCode}"
			responseMap.data = [ name: userCode, codeId: userCode as String, usedCode: userCode, codeName: userCode, method: "keypad" ]
		}
		else
		{
			displayDebugLog("parse(): Cluster is 0101, User is 00 - Door is now locked")
			responseMap.name = "lock"
			responseMap.value = "locked"
			responseMap.descriptionText = "locked"
		}
	}
	else if (cluster == CLUSTER_POWER && attrId == POWER_ATTR_BATTERY_PERCENTAGE_REMAINING) {
		displayDebugLog	("parse(): Cluster is 0001 - Battery info")
		responseMap.name = "battery"
		responseMap.value = Math.round(Integer.parseInt(descMap.value, 16) / 2)
		responseMap.descriptionText = "Battery is at ${responseMap.value}%"
	}
	else if (cluster == "0003") {
		displayDebugLog	("parse(): Cluster is 0003 - Identification request")
		responseMap.name = "lastCheckin"
		responseMap.value = now()
	}
	else {
		displayDebugLog("parse(): Unknow cluster ${cluster}!!***************************")
		responseMap.name = "lastCheckin"
		responseMap.value = now()
	}
	

	if (responseMap.data) {
		responseMap.data.lockName = deviceName
	} else {
		responseMap.data = [ lockName: deviceName ]
	}
	
	
	// createEvent returns a Map that defines an Event
	result = createEvent(responseMap)
	displayDebugLog("parse(): Exiting method returning with event created as follow: $result")
	return result
}








// Reverses order of bytes in hex string
def reverseHexString(hexString) {
	def reversed = ""
	for (int i = hexString.length(); i > 0; i -= 2) {
		reversed += hexString.substring(i - 2, i )
	}
	return reversed
}


// Convert raw 4 digit integer voltage value into percentage based on minVolts/maxVolts range
private parseBattery(description) {
}




//////////////////////////////////////////////////////////////
// capability commands
/////////////////////////////////////////////////////////////
def lock(){
    displayDebugLog ("lock() method called")
    sendEvent(name:"lock",value:"locked", type:"digital")
}

def unlock(){
    displayDebugLog ("unlock() method called")
    sendEvent(name:"lock",value:"unlocked", type:"digital")
}


// configure() runs after installed() when a sensor is paired or reconnected
def configure() {
}

// updated() will run every time user saves preferences
def updated() {
	displayDebugLog ("Updating preference settings")
	init()
	displayDebugLog ("Info message logging enabled")
	displayDebugLog ("Debug message logging enabled")
}

def init() {

}


/**
 * API endpoint for server smart app to scan the lock and populate the attributes. Called only when the attributes are not populated.
 *
 * @return cmds: The command(s) fired for reading attributes
 */
def reloadAllCodes() {
	displayDebugLog ("reloadAllCodes() Executing reloadAllCodes() for device ${device.displayName}")
	sendEvent(name: "scanCodes", value: "Scanning", descriptionText: "Code scan in progress", displayed: false)
	def lockCodes = loadLockCodes()
	sendEvent(lockCodesEvent(lockCodes))
	def cmds = validateAttributes()

	state.checkCode = state.checkCode ?: 0
	cmds += requestCode(state.checkCode)

	displayDebugLog ("reloadAllCodes() returning with cmds:- $cmds")
	return cmds
}

def deleteCode(x) {
    displayDebugLog ("API deleteCode not implemented yet in Baling ")
}

/***** API CALL ****/
def getCodes() {
    displayDebugLog ("getCodes() was called")
    def jsonResponse = getLockCodes()
    displayDebugLog ("getCodes method return :${jsonResponse}")
    sendEvent (name: "lockCodes", value: jsonResponse, descriptionText: "'lockCodes' attribute updated")
    return jsonResponse
}
/***** helper, not apo ******/
private getLockCodes() {
	displayDebugLog ("getLockCodes() was called")
	// def jsonResponse = JsonOutput.toJson([1: "Admin", 11: "Pablo", 12: "Ale", 13: "Dario", 14: "Papa"])
	// return jsonResponse
	return '{1:{name:"Admin",code:"00000000"},11:{name:"Pablo",code:"00000000"},12:{name:"Alejandro",code:"00000000"},13:{name:"Dario",code:"00000000"}}'
}

def setCodeLength(length) {
   displayDebugLog ("API setCodeLength not implemented yet in Baling ")
   def descriptionText = "${device.displayName} codeLength set to ${length}"
   sendEvent(name:"codeLength",value:length,descriptionText:"API setCodeLength not implemented yet in Baling")
}

def setCode(codeNumber, code, name = null) {
    displayDebugLog ("API setCode not implemented yet in Baling ")
}

/*************************************************************************************************************/

/**
 * Reads the 'lockCodes' attribute and parses the same
 *
 * @returns Map: The lockCodes map
 */
private Map loadLockCodes() {
	parseJson(device.currentValue("lockCodes") ?: "{}") ?: [:]
}

private def displayDebugLog(message) {
	if (debugLogging)
		log.debug "${device.displayName}: ${message}"
}

private def displayInfoLog(message) {
	if (infoLogging || state.prefsSetCount != 1)
		log.info "${device.displayName}: ${message}"
}

//Reset the batteryLastReplaced date to current date
def resetBatteryReplacedDate(paired) {
	
}



/**
 * Validates attributes and if attributes are not populated, adds the command maps to list of commands
 * @return List of command maps or empty list
 */
def validateAttributes() {
	def cmds = []
	if (!state.attrAlarmCountSet) {
		state.attrAlarmCountSet = true
		cmds += zigbee.configureReporting(CLUSTER_ALARM, ALARM_ATTR_ALARM_COUNT,
				DataType.UINT16, 0, 21600, null)
	}
	// DOORLOCK_ATTR_SEND_PIN_OTA is sometimes getting reset to 0. Hence, writing it explicitly to 1.
	cmds += zigbee.writeAttribute(CLUSTER_DOORLOCK, DOORLOCK_ATTR_SEND_PIN_OTA, DataType.BOOLEAN, 1)
	if(!device.currentValue("maxCodes")) {
		cmds += zigbee.readAttribute(CLUSTER_DOORLOCK, DOORLOCK_ATTR_NUM_PIN_USERS)
	}
	if(!device.currentValue("minCodeLength")) {
		cmds += zigbee.readAttribute(CLUSTER_DOORLOCK, DOORLOCK_ATTR_MIN_PIN_LENGTH)
	}
	if(!device.currentValue("maxCodeLength")) {
		cmds += zigbee.readAttribute(CLUSTER_DOORLOCK, DOORLOCK_ATTR_MAX_PIN_LENGTH)
	}
	cmds = cmds.flatten()
	displayDebugLog ("validateAttributes returning commands list: $cmds")
	cmds
}

/**
 * Constructs the ZigBee command for user code get
 *
 * @param codeID: The code slot number
 *
 * @return The command for user code get
 */
def requestCode(codeID) {
	return zigbee.command(CLUSTER_DOORLOCK, DOORLOCK_CMD_USER_CODE_GET, getLittleEndianHexString(codeID))
}


/**
 * Returns hex string in little endian format
 */
def getLittleEndianHexString(numStr) {
	return zigbee.swapEndianHex(zigbee.convertToHexString(numStr.toInteger(), 4))
}

/**
 * Populates the 'lockCodes' attribute by calling send event
 *
 * @param lockCodes The codes in a lock
 */
private Map lockCodesEvent(lockCodes) {
	createEvent(name: "lockCodes", value: util.toJson(lockCodes), displayed: false, descriptionText: "'lockCodes' attribute updated")
}




/**
 * Called on app installed
 */
def installed(){
    log.warn "installed..."
    sendEvent(name:"maxCodes",value:20)
    sendEvent(name:"codeLength",value:8)
    lock()
}






/**
* Test Command to test codes
**/
def testUnlockWithCode(code = null){
       displayDebugLog ("testUnlockWithCode() called with code: ${code}")
    /*
	lockCodes in this context calls the helper function getLockCodes()
	*/
    def lockCode = lockCodes.find{ it.value.code == "${code}" }
    displayDebugLog ("testUnlockWithCode() linea despues del lockcode.find que creo que da error! propiedad code?")

    if (lockCode){
        def data = ["${lockCode.key}":lockCode.value]
        def descriptionText = "${device.displayName} was unlocked [physical]"
	displayDebugLog ("testUnlockWithCode() sending unlock event with data: ${data} and dexcription ${descriptionText}")
	sendEvent(name:"lock",value:"unlocked",descriptionText: descriptionText, type:"physical",data:data)
    } else {
        if (txtEnable) log.debug "testUnlockWithCode failed with invalid code"
    }
}
